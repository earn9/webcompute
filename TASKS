NEXT STEPS
	- hook up multi-input runner to front-end
		- use WebSockets to do interactive run
	- latency testing


TASKS
    [x] GLSL Compute Shader runner
        [x] Compile GLSL shader to SPIRV
        [x] Vulkan runner app
            [x] Compile makefile
            [x] runner.cpp -like semantics
        [x] ISPC runner app
            [x] Compile GLSL shader to ISPC
            [x] Add launch[x,y,z] to spirv-to-ISPC output
            [x] Add runner.cpp -like semantics
        [x] GLSL backend target
            [x] Vulkan device enumeration in node info
            [x] /build instance
            [x] /new instance
        [x] Front-end
            [x] Send GLSL shader to ISPC and Vulkan targets: 
                [x] /new {language: 'glsl', target: 'vulkan', device: 0}
                [x] /new {language: 'glsl', target: 'ispc'}
                - That's... it?

    [] Distribution network
        [] Latency limit to restrict node selection
        [] Job distribution network
        [] Reducer network

    [] Render machinery
        [x] Long-running process for running Vulkan jobs
            [x] Start process on receiving first job
            [] Receive new kernels and inputs via socket
            [] Keep latest shader pipeline + buffer alloc cached
        [] Long-running process for running ISPC with different inputs
            [] Not very important, ISPC startup time is quite minimal
            [] Keep process up and receive new inputs via socket

    [] Target optimization
        [] Either figure out
            - how to make GLSL AOBench perf match ISPC
            - how to pass separate kernels to different targets

    [x] Windows port
        [x] Run on the Dell laptop /w Win10
        [] Run on the i7-3770k

    [x] Termux port
        [x] Run on Nokia 8
        [x] Run on Note 5
        [x] Run on Tab S3

    [] ARM Linux ports
        [] Run on webcam
        [] Run on RC car
        [] Run on light switch
