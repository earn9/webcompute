NEXT STEPS
- GLSL backend
    [] buildSPIRV()
        [] Compile .glsl to .spv
    [] runGLSLJob()
        [] make TARGET=balabala spirv
        [] make TARGET=balabala ARCH=bla PLATFORM=blo MY_ARCH=foo MY_PLATFORM=bar ispc-cross ispc ispc-bin
        [] targets/balabala/program <input | res.socket



TASKS
    [] GLSL Compute Shader runner
        [x] Compile GLSL shader to SPIRV
        [x] Vulkan runner app
            [x] Compile makefile
            [x] runner.cpp -like semantics
        [x] ISPC runner app
            [x] Compile GLSL shader to ISPC
            [x] Add launch[x,y,z] to spirv-to-ISPC output
            [x] Add runner.cpp -like semantics
        [] GLSL backend target
            [] Vulkan device enumeration in node info
            [] /build instance
            [] /new instance
        [] Front-end
            [] Send GLSL shader to ISPC and Vulkan targets: 
                [] /new {language: 'glsl', target: 'vulkan', device: 0}
                [] /new {language: 'glsl', target: 'ispc'}
                - That's... it?

    [] Distribution network
        [] Latency limit to restrict node selection
        [] Job distribution network
        [] Reducer network



